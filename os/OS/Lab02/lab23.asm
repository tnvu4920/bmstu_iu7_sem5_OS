.386P
desct struc  ; структура описания дескрипторов сегментов
		limit	dw 0		; граница (биты 0..15)
		base_l	dw 0		; база (биты 0..15)
		base_m	db 0		; база (биты 16..23)
		attr_1	db 0		; атрибуты 1
		attr_2	db 0		; граница (биты 16..19) и атрибуты 2
		base_h	db 0		; база (биты 24..32)
desct ends

int_descr struc				; структура для описания декскриптора прерывания
		offs_l 		dw 0 	; Младшие 16 битов адреса, куда происходит переход в случае возникновения прерывания.
		sel			dw 0	; Селектор сегмента с кодом прерывания/Переключатель сегмента ядра
		counter		db 0	; Счётчик, не используется в программе. Всегда ноль!
		attr		db 0	; Атрибуты
		offs_h 		dw 0	; Старшие 16 битов адреса, куда происходит переход.
int_descr ends


print_str macro str
		mov ah,9
		mov dx, str
		int 21h
endm

; макро функция преобразования числа в символ
create_number macro
		local number1
			cmp dl,10
			jl number1
			add dl,'A' - '0' - 10
		number1:
			add dl,'0'
endm

; макро функция печати значения из регистра ЕАХ
my_print_eax macro
	local prcyc1 				
		push ecx 					
		push dx

		mov ecx,8					; количество символов, которые печатаем
		add ebp,100h				; позиция первого символа на экране
	
	prcyc1:
		mov dl,al					; загружаем в DL текущее значение AL (самый младший байт ЕАХ)
		and dl,0Fh					; оставляем от него одно 16ричное число (последняя цифра)
		create_number 0				; превращаем это число в символ
		mov es:[ebp],dl				; записываем его в видеобуфер
		ror eax,4					; циклически двигаем биты в ЕАХ - таким образом, после всех перестановок,
									; ЕАХ окажется тем же что и в начале
		sub ebp,2					; смещаемся на один символ влево (предыдущая цифра в ЕАХ)
		loop prcyc1					; повторяемся 8 раз

		sub ebp,0B8010h				; возвращаем в EBP то же значение, что было в нём до пляски с видеопамятью
		pop dx
		pop ecx
endm



data segment
; структура для описания дескрипторов сегментов GDT
		GDT			label	byte
		gdt_null	desct <0,0,0,0,0,0>						; Селектор О, нулевой дескриптор
		gdt_data	desct <data_size-1,0,0,92h>				; Селектор 8, сегмент данных
		gdt_code	desct <code_size-1,,,98h>				; Селектор 16, сегмент команд 
		gdt_stack	desct <255,0,0,92h>						; Селектор 24, сегмент стека 
		gdt_screen	desct <4095,8000h,0Bh,92h>				; Селектор 32, видеопамять 
		gdt_DS		desct <0FFFFh,0,10h,92h,10001111b,0>	; Селектор 40, старшая память
		gdt_size = $-gdt_null	
		; размер GDT

		IDT		label	byte
		int_descr 32 dup (<0, 16,0, 8Eh, 0>)		; первые 32 элемента таблицы
		int08 int_descr <0, 16,0, 8Eh, 0>			; дескриптор прерывания от таймера
		int09 int_descr	<0, 16,0, 8Eh, 0>			; дескриптор прерывания от клавиатуры
		idt_size = $-IDT							; размер нашей таблицы IDT+1байт (на саму метку)
		
		pdescr	df 0												; псевдодескриптор для команды ldgt
		attr_o 	db 1Eh												; атрибут для вывода символа в видеопамять
		msg1     db 'Process working in real mode! To move to Protected Mode press any key...',13,10,'$'		; сообщение о переходе в реальный режим
		msg2     db 'Process working in protected mode! ',13,10,'$'	; сообщение о переходе в защищенный режим
		msg3     db 'Process working in real mode! ',13,10,'$'		; сообщение о переходе в реальный режим
		msg_null db 13,10,'$'										; переход на новую строку
										; размер сегмента данных
		idtr df 0
		idtr_real dw	3FFh,0,0 ; содержимое регистра IDTR в реальном режиме

		master	db 0					 ; маска прерываний ведущего контроллера
		slave	db 0					 ; ведомого

		escape		db 0				 ; флаг - пора выходить в реальный режим, если ==1
		time_08		dd 0				 ; счетчик прошедших тиков таймера

		;msg1 db 'In Real Mode now. To move to Protected Mode press any key...$'
		;msg2 db 'In Real Mode again!$'

		; Таблица символов ASCII для перевода из скан кода в код ASCII.
		; Номер скан кода = номеру соответствующего элемента в таблице:
		ASCII_table	db 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 45, 61, 0, 0
					db 81, 87, 69, 82, 84, 89, 85, 73, 79, 80, 91, 93, 0, 0, 65, 83
					db 68, 70, 71, 72, 74, 75, 76, 59, 39, 96, 0, 92, 90, 88, 67
					db 86, 66, 78, 77, 44, 46, 47
		out_position	dd 180h ; Позиция печати вводимого текста
		data_size=$-gdt_null
data ends


text segment 'code' use16
	assume CS:text,DS:data


calc_memory	proc

		push	ds            ; сохраняем прошлое значение DS
		mov	ax, 40				; кладем в него сегмент на 4 ГБ - все доступное виртуальное АП
		mov	ds, ax					
		mov	ebx, 100001h		; пропускаем первый мегабайт оного сегмента
		mov	dl,	10101010b	  ; попытка считать значение из несуществующего байта памяти вернёт все нули (или все единицы)
												; в каждый байт мы пишем какое-то значение, а потом смотрим, что прочитается

		mov	ecx, 0FFEFFFFEh	; в ECX кладём количество оставшейся памяти (до превышения лимита в 4ГБ) - чтобы не было переполнения

		; в цикле считаем память
	check:
		mov	dh, ds:[ebx]		; сохраняем в DH текущее значение по некоторому байту памяти
												; EBX на первой итерации содержит смещение за 1й мегабайт памяти
												; мегабайт пропускаем потому, что в противном случае может произойти
												; попытка редактирования процедуры собственного кода, что есть крайне не торт
		mov	gs:[ebx], dl		; кладём некоторое значение (заданное выше DL) в этот байт
		cmp	gs:[ebx], dl		; проверяем - считается обратно то же DL, или какая-то хрень
		jnz	end_of_memory		
		mov	gs:[ebx], dh		; если дна не достигли - кладём обратно сохранённое значение, чтобы не попортить лишнего на всякий
		inc	ebx							
		db 67h
		loop	check
	end_of_memory:
		pop	ds							; мемориджоб подошёл к логическому концу, память кончилась - восстанавливаем регистры
		xor	edx, edx
		mov	eax, ebx				; в EBX лежит количество посчитанной памяти в байтах; кладём его в EAX,
		;mov	ebx, 100000h		; делим на 1 Мб, чтобы получить результат в мегабайтах
		;div	ebx

		push ebp
		mov ebp,82				; указываем смещение в видеопамяти относительно начала экрана (10 символов - 1 байт символа и 1 байт цвета )
		my_print_eax 0			; вызываем макрос видео-печати
		pop ebp							; восстанавливаем потраченное смещение EBP

		ret
calc_memory	endp

new_int08:
		push eax
		push ebp
		push ecx
		push dx
		mov  eax,time_08

		; кладём в EBP смещение на 8 символов от начала экрана
		push ebp
		mov ebp, 100			; указываем смещение в видеопамяти относительно начала экрана (10 символов - 1 байт символа и 1 байт цвета )
		my_print_eax 0			; вызываем макрос видео-печати
		pop ebp							; восстанавливаем потраченное смещение EBP

		inc eax
		mov time_08,eax

		pop dx
		pop ecx
		pop ebp

	; отправляем команду End of Interrupt ведущему контроллеру прерываний
		mov	al,20h
		out	20h,al
		pop eax

		iretd ;выходим из прерывания

		; Новый обработчик прерывания клавиатуры для защищенного режима:
new_int09:
		push eax
		push ebx
		push ebp
		push edx

		in	al,60h 		 ; Получаем скан-код нажатой клавиши из порта клавиатуры

		cmp	al,1Ch 	     ; Сравниваем с кодом энтера
		jne	not_leave 	 ; Если не энтер - ввыведем, то что ввели
		mov escape,1     ; Если энтер - ставим флаг, что нужно вернуться в реальный режим
		jmp leav
not_leave:
		cmp al,80h 	 ; Сравним какой скан-код пришел: нажатой клавиши или отжатой?
		ja leav 	 ; Если отжатой, то ничего не выводим
		xor ah,ah	 ; Если нажатой, то выведем на экран
		mov bp,ax
		mov dl,ASCII_table[ebp] ; Получим ASCII код нажатой клавиши по скан коду из таблицы
		mov ebp,100
		mov ebx,out_position   ; Текущая позиция вывода символа
		mov es:[ebp+ebx],dl

		add ebx,2			   ; Увеличим текущую позицию вывода текста и сохраним ее
		mov out_position,ebx

leav:
		; Разрешаем обрабатывать клавиатуру дальше:
		in	al,61h
		or	al,80h
		out	61h,al

		; Посылаем сигнал EOI:
		mov	al,20h
		out	20h,al

		pop edx
		pop ebp
		pop ebx
		pop	eax

		; Выходим из прерывания:
		iretd



main proc
		xor		EAX, EAX
		mov		AX, data						; загрузка сегметного адреса
		mov		DS, AX							; сегмента данных в DS
		
		push eax
		mov	ax,3								; очистка экрана
		int	10h
		
		mov ah, 09h
		mov edx, offset msg1
		int 21h

		;ожидаем ввода клавиатуры
		push eax;сохраняем, чтоб не потерять AX
		mov ah,10h
		int 16h
		pop eax;и восстанавливаем
		pop eax

		; вычисление линейных адресов сегментов
		shl		EAX, 4					; сдвигаем влево AX на 4 байта
		mov 	EBP, EAX				; загружаем в АХ сегментный адрес сегмента данных			
		mov 	BX, offset gdt_data		; загружаем в BX смещение дескриптора 
		mov 	[BX].base_l, AX			; загружаем младшую часть базы
		rol		EAX, 16					; переносим старшую половину EAX и AX
		mov 	[BX].base_m, AL			; загружаем среднюю часть базы

		xor		EAX, EAX
		mov 	AX, CS					; загружаем в АХ сегментный адрес сегмента кода
		shl 	EAX, 4					; сдвигаем влево AX на 4 байта	
		mov 	BX, offset gdt_code		; загружаем в BX смещение дескриптора 
		mov 	[BX].base_l, AX			; загружаем младшую часть базы
		rol 	EAX, 16					; переносим старшую половину EAX и AX
		mov 	[BX].base_m, AL			; загружаем среднюю часть базы

		xor 	EAX, EAX
		mov 	AX, SS					; загружаем в АХ сегментный адрес сегмента стека
		shl 	EAX, 4					; сдвигаем влево AX на 4 байта
		mov 	BX, offset gdt_stack	; загружаем в BX смещение дескриптора 
		mov 	[BX].base_l, AX			; загружаем младшую часть базы
		rol 	EAX, 16					; переносим старшую половину EAX и AX
		mov 	[BX].base_m, AL			; загружаем среднюю часть базы

		; подготовка псевдодескриnтора pdescr и загрузка регистра GDTR 
		mov 	dword ptr pdescr+2, EBP		; загружаем базу GDT	
		mov 	word ptr pdescr, gdt_size-1	; загружаем границу GDT
		lgdt 	pdescr						; загружаем псевдодескриптор в регистр GDTR 
		
		; подготовка псевдодескриnтора прерываний
		mov	EAX, EBP
		add	EAX,offset IDT
		mov	dword ptr idtr+2,EAX
		mov word ptr idtr, idt_size-1

		; Заполним смещение в дескрипторах прерываний
		mov	eax, offset new_int08 ; прерывание таймера
		mov	int08.offs_l, ax
		shr	eax, 16
		mov	int08.offs_h, ax

		mov	eax, offset new_int09 ; прерывание клавиатуры
		mov	int09.offs_l, ax
		shr	eax, 16
		mov	int09.offs_h, ax

		; сохраним маски прерываний контроллеров
		in	al, 21h							; ведущего, 21h - номер шины, in на неё даст нам набор масок (флагов)
		mov	master, al					; сохраняем в переменной master (понадобится для возвращения в RM)
		in	al, 0A1h						; ведомого - аналогично, in даёт набор масок для ведомого
		mov	slave, al

		; перепрограммируем ведущий контроллер
		mov	al, 11h							; команда "инициализировать ведущий контроллер"
		out	20h, al							; 20h - порт включения\выключения
		
		; Слова команд инициализации (СКИ)
		mov	AL, 20h							; базовый вектор (начальное смещение для обработчика) теперь 32 (20h)
		out	21h, al							; указываем, что аппаратные прерывания будут обрабатываться начиная с 32го (20h)
		mov	al, 4							; указываем, какой вход IRQ соответствует ведомому контроллеру	
		out	21h, al
		mov	al, 1							; указываем, что нужно будет посылать команду завершения обработчика прерывания
		out	21h, al

		; Запретим все прерывания в ведущем контроллере, кроме IRQ0 (таймер) и IRQ1(клавиатура)
		mov	al, 0FCh
		out	21h, al

		;запретим ВООБЩЕ ВСЕ прерывания в ведомом контроллере
		;в противном случае возникнет исключение - может прийти прерывание, для которого у нас не написан обработчик
		mov	al, 0FFh
		out	0A1h, al

		; загрузим IDT
		lidt	fword ptr idtr

		
		; открытие линии A20
		mov AL,0D1h
		out 64h,AL
		mov AL,0DFh
		out 60h,AL

		cli								; запрет аппаратных прерываний

		; затем вдогонку и немаскируемые прерывания
		in	al,70h
		or	al,80h
		out	70h,al
		
		;mov 	AL, 80h					; запрет маскируемых прерываний
		;out 	70h, AL

		mov 	EAX, CR0				; получаем содержимое регистра CR0
		or 		EAX, 1					; устанавливаем бит PE
		mov 	CR0, EAX				

		; -------------------------------------------
		; Процессор работает в защищенном режиме
		; -------------------------------------------
		; Загрузка селектора в CS с помощью дальнего перехода
		db 		0EAh					; код команды far jmp
		dw		offset continue			; смещение
		dw 		16						; селектор сегмента команд
	continue:
		; сделаем адресуемыми данные
		mov		AX, 8					; селектор сегмента данных
		mov 	DS, AX
		; сделаем адресуемым стек
		mov		AX, 24					; селектор сегмента стека
		mov		SS, AX
		; инициализируем видеобуфер
		mov		AX, 32					; селектор сегмента видеобуфера
		mov 	ES, AX
		mov		BX, stack_l
		mov		SP, BX

		sti

		call calc_memory		; считаем доступную память

		; вывод сообщения в видеобуфер
		mov 	BX, 170			; начальная позиция вывода в видеобуфере
		mov 	CX, 34			; длина строки
		mov		SI, 0
		mov 	AL, msg2[SI]	; загружаем в AL символ строки
		mov		AH, attr_o		; загружаем в AH атрибут символа

	screen: 
		mov ES:[BX], AX			; выводим символ в видеобуфер
		add 	BX, 2
		add 	SI,1
		mov 	AL, msg2[SI]
		loop	screen

	work:
		test	escape, 1
		jz	work

	goback:
		; запрещаем прерывания, всё по той же причине
		; при этом немаскируемые уже запрещены, их не трогаем
		cli ; сброс флага прерывания IF = 0

		; закрытие линии А20
		mov AL, 0D1h
		out 64h,AL
		mov AL, 0DDh
		out 60h, AL

		mov 	gdt_data.limit, 	0FFFFh		; загружаем границу сегмента данных
		mov 	gdt_code.limit, 	0FFFFh		; загружаем границу сегмента кода
		mov 	gdt_stack.limit, 	0FFFFh		; загружаем границу сегмента стека
		mov		gdt_screen.limit,	0FFFFh		; загружаем границу доп. сегмента
		
		; загрузка селекторов в сегментные регистры (перезапись содержимого теневых регистров)
		mov		AX, 8
		mov 	DS, AX		; загрузка теневого регистра сегмента данных
		mov 	AX, 24
		mov 	SS, AX		; загрузка теневого регистра сегмента стека
		mov 	AX, 32	
		mov 	ES, AX		; загрузка теневого регистра доп. сегмента 
		
		; Загружаем в CS селектор с помощью дальнего перехода (загрузка
		; теневого регистра сегмента кода)
		db		0EAh		
		dw		offset go
		dw 		16

	go:	
		mov		EAX, CR0			; получим содержимое регистра CR0
		and		EAX, 0FFFFFFFEh		; сбросим бит PE
		mov 	CR0, EAX			; запишем назад в CR0

		; Загружаем в CS сегментный адрес сегмента кода с помощью дальнего
		; перехода (загрузка теневого регистра сегмента кода)
		db 		0EAh
		dw 		offset return
		dw 		text

		; -------------------------------------------
		; Процессор работает в реальном режиме
		; -------------------------------------------
return:
		mov AX, data			; сделаем адресуемыми данные
		mov		DS, AX
		mov 	AX, stk			; сделаем адресуемым стек
		mov 	SS, AX
		mov		BX, stack_l
		mov		SP, BX

		;перепрограммируем ведущий контроллер обратно на вектор 8 - смещение, по которому вызываются стандартные обработчики прерываний в реалмоде
		mov	al, 11h					; инициализация
		out	20h, al					; порт 20h - ведущий контроллер прерываний
		mov	al, 8						; отправка смещения
		out	21h, al
		mov	al, 4						; волшебные команды, "код - работай!"
		out	21h, al
		mov	al, 1
		out	21h, al

		;восстанавливаем предусмотрительно сохраненные ранее маски контроллеров прерываний
		mov	al, master
		out	21h, al
		mov	al, slave
		out	0A1h, al

		; загружаем таблицу дескрипторов прерываний реального режима
		lidt	fword ptr idtr_real

		; разрешаем обратно немаскируемые прерывания
		in	al,70h
		and	al,07FH
		out	70h,al

        ; а затем маскируемые
		sti

		;sti						; разрешаем аппаратные прерывания
		;mov		AL, 0			; разрешаем маскируемые прерывания
		;out 	70h, AL

		mov 	AH, 09h					; переход на новую строку
		mov 	DX, offset msg_null
		int 	21h
		mov 	AH, 09h					; переход на новую строку
		mov 	DX, offset msg_null
		int 	21h
		mov 	AH, 09h					; переход на новую строку
		mov 	DX, offset msg_null
		int 	21h
		mov 	AH, 09h					; печать сообщения
		mov 	DX, offset msg3
		int 	21h 



		mov 	AX, 4C00h		; завершение программы
		int 	21h
main endp

code_size=$-main				; размер сегмента кода
text ends

stk 	segment stack 'stack'
		stack_start db 	256 dup ('^')
		stack_l = $-stack_start	
stk 	ends
end main